# Error Reporting System - AI & Human Readable

*Auto-generated from user requirement: "send any errors sent to ui front end to most readable place for the ai & human"*

## üéØ Core Requirement

**Problem**: Errors scattered across console, terminal, UI alerts - difficult for AI to parse and debug
**Solution**: Centralized error display system with structured, readable output

## üìç Error Display Location

### Primary Error Panel (Frontend)
```html
<!-- Add to frontend/core/index.html -->
<div id="error-panel" class="error-panel hidden">
  <div class="error-header">
    <h3>System Errors</h3>
    <button id="clear-errors" class="clear-btn">Clear</button>
    <button id="toggle-errors" class="toggle-btn">Hide</button>
  </div>
  <div id="error-list" class="error-list"></div>
</div>
```

### Error Panel Styling (Readable & Accessible)
```css
/* Add to frontend/assets/style.css */
.error-panel {
  position: fixed;
  top: 10px;
  right: 10px;
  width: 400px;
  max-height: 60vh;
  background: rgba(20, 20, 20, 0.95);
  border: 2px solid #ff4444;
  border-radius: 8px;
  z-index: 10000;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  backdrop-filter: blur(10px);
}

.error-panel.hidden {
  display: none;
}

.error-header {
  background: #ff4444;
  color: white;
  padding: 8px 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.error-header h3 {
  margin: 0;
  font-size: 14px;
  font-weight: bold;
}

.clear-btn, .toggle-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}

.clear-btn:hover, .toggle-btn:hover {
  background: rgba(255, 255, 255, 0.3);
}

.error-list {
  max-height: 50vh;
  overflow-y: auto;
  padding: 0;
}

.error-item {
  border-bottom: 1px solid #333;
  padding: 12px;
  color: #fff;
  font-size: 12px;
  line-height: 1.4;
}

.error-item:last-child {
  border-bottom: none;
}

.error-timestamp {
  color: #888;
  font-size: 10px;
  margin-bottom: 4px;
}

.error-type {
  color: #ff6666;
  font-weight: bold;
  margin-bottom: 4px;
}

.error-message {
  color: #fff;
  margin-bottom: 4px;
  word-wrap: break-word;
}

.error-stack {
  color: #ccc;
  font-size: 11px;
  white-space: pre-wrap;
  margin-top: 8px;
  max-height: 100px;
  overflow-y: auto;
  background: rgba(0, 0, 0, 0.3);
  padding: 8px;
  border-radius: 4px;
}

.error-source {
  color: #88ccff;
  font-size: 11px;
  margin-top: 4px;
}
```

## üîß Centralized Error Handler

### Global Error Collection System
```javascript
// Add to frontend/core/app.js or new file: frontend/components/error-handler.js

class ErrorReporter {
  constructor() {
    this.errors = [];
    this.maxErrors = 50;
    this.init();
  }

  init() {
    // Capture all JavaScript errors
    window.addEventListener('error', (event) => {
      this.reportError({
        type: 'JavaScript Error',
        message: event.message,
        source: `${event.filename}:${event.lineno}:${event.colno}`,
        stack: event.error?.stack,
        timestamp: new Date()
      });
    });

    // Capture unhandled promise rejections
    window.addEventListener('unhandledrejection', (event) => {
      this.reportError({
        type: 'Unhandled Promise Rejection',
        message: event.reason?.message || event.reason,
        source: 'Promise',
        stack: event.reason?.stack,
        timestamp: new Date()
      });
    });

    // Setup UI handlers
    this.setupUI();
  }

  reportError(error) {
    // Add to errors array
    this.errors.unshift(error);
    
    // Limit array size
    if (this.errors.length > this.maxErrors) {
      this.errors = this.errors.slice(0, this.maxErrors);
    }

    // Update UI
    this.updateErrorPanel();

    // Log to console for AI parsing
    console.error('üö® ERROR REPORTED:', {
      timestamp: error.timestamp.toISOString(),
      type: error.type,
      message: error.message,
      source: error.source,
      stack: error.stack
    });

    // Send to server for logging (optional)
    this.sendToServer(error);
  }

  // Manual error reporting for custom errors
  report(type, message, source = 'Manual', stack = null) {
    this.reportError({
      type,
      message,
      source,
      stack,
      timestamp: new Date()
    });
  }

  updateErrorPanel() {
    const panel = document.getElementById('error-panel');
    const errorList = document.getElementById('error-list');
    
    if (!panel || !errorList) return;

    // Show panel if hidden and has errors
    if (this.errors.length > 0) {
      panel.classList.remove('hidden');
    }

    // Update error list
    errorList.innerHTML = this.errors.map(error => `
      <div class="error-item">
        <div class="error-timestamp">${error.timestamp.toLocaleString()}</div>
        <div class="error-type">${error.type}</div>
        <div class="error-message">${error.message}</div>
        <div class="error-source">${error.source}</div>
        ${error.stack ? `<div class="error-stack">${error.stack}</div>` : ''}
      </div>
    `).join('');
  }

  setupUI() {
    // Clear errors button
    document.addEventListener('click', (e) => {
      if (e.target.id === 'clear-errors') {
        this.clearErrors();
      }
      if (e.target.id === 'toggle-errors') {
        this.togglePanel();
      }
    });
  }

  clearErrors() {
    this.errors = [];
    this.updateErrorPanel();
    document.getElementById('error-panel').classList.add('hidden');
  }

  togglePanel() {
    const panel = document.getElementById('error-panel');
    panel.classList.toggle('hidden');
  }

  sendToServer(error) {
    // Optional: Send errors to backend for logging
    fetch('/api/log-error', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(error)
    }).catch(() => {
      // Fail silently if server unavailable
    });
  }

  // AI-readable error summary
  getErrorSummary() {
    return {
      totalErrors: this.errors.length,
      recentErrors: this.errors.slice(0, 5),
      errorTypes: [...new Set(this.errors.map(e => e.type))],
      commonSources: this.getMostCommonSources()
    };
  }

  getMostCommonSources() {
    const sources = this.errors.map(e => e.source);
    const counts = {};
    sources.forEach(source => counts[source] = (counts[source] || 0) + 1);
    return Object.entries(counts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([source, count]) => ({ source, count }));
  }
}

// Initialize global error reporter
window.errorReporter = new ErrorReporter();

// Convenience function for manual error reporting
window.reportError = (type, message, source) => {
  window.errorReporter.report(type, message, source);
};
```

## üéØ Integration Points

### Backend Error Logging (Optional)
```javascript
// Add to backend/api/server.js
app.post('/api/log-error', (req, res) => {
  const error = req.body;
  
  // Log to console for AI reading
  console.error('üö® FRONTEND ERROR:', JSON.stringify({
    timestamp: error.timestamp,
    type: error.type,
    message: error.message,
    source: error.source,
    userAgent: req.get('User-Agent')
  }, null, 2));
  
  // Optionally log to file or database
  
  res.status(200).json({ status: 'logged' });
});
```

### Custom Error Usage Examples
```javascript
// In payment.js - report payment errors
try {
  await processPayment();
} catch (error) {
  errorReporter.report('Payment Error', error.message, 'payment.js');
}

// In camera.js - report camera errors  
if (!navigator.mediaDevices) {
  errorReporter.report('Camera Error', 'MediaDevices not supported', 'camera.js');
}

// In any component - report validation errors
if (!isValid) {
  errorReporter.report('Validation Error', 'Invalid input format', 'validation');
}
```

## üìä AI-Readable Output Format

### Console Output Structure
```
üö® ERROR REPORTED: {
  "timestamp": "2025-01-18T20:15:30.000Z",
  "type": "JavaScript Error",
  "message": "Cannot read property 'textContent' of null",
  "source": "app.js:45:12",
  "stack": "TypeError: Cannot read property...\n    at app.js:45:12\n    at HTMLButtonElement.onclick"
}
```

### Error Summary API (for AI analysis)
```javascript
// AI can call: window.errorReporter.getErrorSummary()
// Returns:
{
  "totalErrors": 3,
  "recentErrors": [...],
  "errorTypes": ["JavaScript Error", "Payment Error"],
  "commonSources": [
    { "source": "payment.js", "count": 2 },
    { "source": "app.js:45:12", "count": 1 }
  ]
}
```

## üö´ Implementation Rules

### MANDATORY Requirements:
1. **Always visible** - Error panel shows automatically when errors occur
2. **AI-parseable** - Console logs in structured JSON format
3. **Human-readable** - Clear typography and layout in UI panel
4. **Non-blocking** - Errors don't prevent app functionality
5. **Persistent** - Errors remain visible until manually cleared

### Error Reporting Standards:
- **Include timestamp** for chronological debugging
- **Specify source file/line** for precise location
- **Preserve stack traces** for debugging context
- **Categorize error types** for pattern recognition
- **JSON format** for AI parsing

## üîÑ Auto-Update Protocol

### When new error patterns emerge:
1. **Update this file** with new error types
2. **Add specific handlers** for recurring errors
3. **Enhance error categorization** based on patterns
4. **Update UI styling** if readability improvements needed

### Fixed Error Patterns:
- **404 POST /analyze-text**: Missing frontend compatibility endpoint ‚Üí Added /analyze-text mapping to existing /object-molecules logic
- **Frontend/Backend API Mismatch**: Frontend expects /analyze-text, backend had /object-molecules ‚Üí Created compatibility layer

---

**This system ensures all errors are immediately visible to both AI and humans in a structured, debuggable format.**
