# Testing Patterns

## Test File Organization
- **Unit Tests**: `unit.test.js` - Test individual functions and classes
- **Integration Tests**: `integration.test.js` - Test complete workflows
- **Smoke Tests**: `smoke.test.js` - Test basic functionality
- **System Tests**: `system.test.js` - Test full system integration

## Test Structure
```javascript
describe('Component/Class Name', () => {
  let component;
  
  beforeEach(() => {
    component = new Component('test-params');
  });
  
  afterEach(() => {
    // Cleanup if needed
  });
  
  test('should do something specific', async () => {
    const result = await component.method();
    expect(result).toHaveProperty('expected');
  });
});
```

## Test Naming Conventions
- **Test Descriptions**: Use "should" statements (e.g., "should initialize with API key")
- **Group Descriptions**: Use component/class names (e.g., `describe('AtomPredictor', () => {`)
- **Test Cases**: Be specific about what is being tested

## Mocking Patterns
```javascript
// Mock external dependencies
jest.mock('../AtomPredictor');

// Mock API responses
const mockResponse = {
  object: "test object",
  chemicals: [{ name: "Test", smiles: "CCO" }]
};

// Mock file system
jest.mock('fs', () => ({
  existsSync: jest.fn(),
  readFileSync: jest.fn()
}));
```

## Async Testing
```javascript
test('should handle async operations', async () => {
  const result = await asyncFunction();
  expect(result).toBeDefined();
});

test('should handle errors', async () => {
  await expect(asyncFunction()).rejects.toThrow('Error message');
});
```

## Validation Testing
- **Input Validation**: Test invalid inputs and edge cases
- **Output Validation**: Verify correct response structure
- **Error Handling**: Test error conditions and messages
- **Boundary Testing**: Test limits and edge cases

## Integration Test Patterns
```javascript
describe('API Integration', () => {
  test('should process complete workflow', async () => {
    // Test from input to final output
    const input = { imageBase64: 'test-data' };
    const result = await processCompleteWorkflow(input);
    expect(result).toHaveProperty('molecules');
  });
});
```

## Test Data Management
- **Fixtures**: Use consistent test data
- **Cleanup**: Reset state between tests
- **Isolation**: Each test should be independent
- **Realistic Data**: Use realistic but safe test data

## Performance Testing
- **Response Times**: Test API response times
- **Memory Usage**: Monitor memory consumption
- **Load Testing**: Test with multiple concurrent requests
- **Resource Cleanup**: Ensure proper cleanup after tests

## Test Coverage
- **Unit Coverage**: Aim for >80% unit test coverage
- **Integration Coverage**: Test all major workflows
- **Error Paths**: Test error conditions and edge cases
- **Critical Paths**: Ensure core functionality is tested
description:
globs:
alwaysApply: false
---
